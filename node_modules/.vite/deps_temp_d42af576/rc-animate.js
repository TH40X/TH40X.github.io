import {
  require_react_dom
} from "./chunk-GYWC62UC.js";
import {
  require_react
} from "./chunk-HS5T2ZWL.js";
import {
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/rc-animate/es/Animate.js
var import_react4 = __toESM(require_react());

// node_modules/rc-animate/node_modules/rc-util/es/unsafeLifecyclesPolyfill.js
var import_react = __toESM(require_react());
var unsafeLifecyclesPolyfill = function unsafeLifecyclesPolyfill2(Component) {
  var prototype = Component.prototype;
  if (!prototype || !prototype.isReactComponent) {
    throw new Error("Can only polyfill class components");
  }
  if (typeof prototype.componentWillReceiveProps !== "function") {
    return Component;
  }
  if (!import_react.default.Profiler) {
    return Component;
  }
  prototype.UNSAFE_componentWillReceiveProps = prototype.componentWillReceiveProps;
  delete prototype.componentWillReceiveProps;
  return Component;
};
var unsafeLifecyclesPolyfill_default = unsafeLifecyclesPolyfill;

// node_modules/rc-animate/es/ChildrenUtils.js
var import_react2 = __toESM(require_react());
function toArrayChildren(children) {
  var ret = [];
  import_react2.default.Children.forEach(children, function(child) {
    ret.push(child);
  });
  return ret;
}
function findChildInChildrenByKey(children, key) {
  var ret = null;
  if (children) {
    children.forEach(function(child) {
      if (ret) {
        return;
      }
      if (child && child.key === key) {
        ret = child;
      }
    });
  }
  return ret;
}
function findShownChildInChildrenByKey(children, key, showProp) {
  var ret = null;
  if (children) {
    children.forEach(function(child) {
      if (child && child.key === key && child.props[showProp]) {
        if (ret) {
          throw new Error("two child with same key for <rc-animate> children");
        }
        ret = child;
      }
    });
  }
  return ret;
}
function isSameChildren(c1, c2, showProp) {
  var same = c1.length === c2.length;
  if (same) {
    c1.forEach(function(child, index) {
      var child2 = c2[index];
      if (child && child2) {
        if (child && !child2 || !child && child2) {
          same = false;
        } else if (child.key !== child2.key) {
          same = false;
        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
          same = false;
        }
      }
    });
  }
  return same;
}
function mergeChildren(prev, next) {
  var ret = [];
  var nextChildrenPending = {};
  var pendingChildren = [];
  prev.forEach(function(child) {
    if (child && findChildInChildrenByKey(next, child.key)) {
      if (pendingChildren.length) {
        nextChildrenPending[child.key] = pendingChildren;
        pendingChildren = [];
      }
    } else {
      pendingChildren.push(child);
    }
  });
  next.forEach(function(child) {
    if (child && Object.prototype.hasOwnProperty.call(nextChildrenPending, child.key)) {
      ret = ret.concat(nextChildrenPending[child.key]);
    }
    ret.push(child);
  });
  ret = ret.concat(pendingChildren);
  return ret;
}

// node_modules/rc-animate/es/AnimateChild.js
var import_react3 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@ant-design/css-animation/es/Event.js
var START_EVENT_NAME_MAP = {
  transitionstart: {
    transition: "transitionstart",
    WebkitTransition: "webkitTransitionStart",
    MozTransition: "mozTransitionStart",
    OTransition: "oTransitionStart",
    msTransition: "MSTransitionStart"
  },
  animationstart: {
    animation: "animationstart",
    WebkitAnimation: "webkitAnimationStart",
    MozAnimation: "mozAnimationStart",
    OAnimation: "oAnimationStart",
    msAnimation: "MSAnimationStart"
  }
};
var END_EVENT_NAME_MAP = {
  transitionend: {
    transition: "transitionend",
    WebkitTransition: "webkitTransitionEnd",
    MozTransition: "mozTransitionEnd",
    OTransition: "oTransitionEnd",
    msTransition: "MSTransitionEnd"
  },
  animationend: {
    animation: "animationend",
    WebkitAnimation: "webkitAnimationEnd",
    MozAnimation: "mozAnimationEnd",
    OAnimation: "oAnimationEnd",
    msAnimation: "MSAnimationEnd"
  }
};
var startEvents = [];
var endEvents = [];
function detectEvents() {
  var testEl = document.createElement("div");
  var style = testEl.style;
  if (!("AnimationEvent" in window)) {
    delete START_EVENT_NAME_MAP.animationstart.animation;
    delete END_EVENT_NAME_MAP.animationend.animation;
  }
  if (!("TransitionEvent" in window)) {
    delete START_EVENT_NAME_MAP.transitionstart.transition;
    delete END_EVENT_NAME_MAP.transitionend.transition;
  }
  function process(EVENT_NAME_MAP, events) {
    for (var baseEventName in EVENT_NAME_MAP) {
      if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
        var baseEvents = EVENT_NAME_MAP[baseEventName];
        for (var styleName in baseEvents) {
          if (styleName in style) {
            events.push(baseEvents[styleName]);
            break;
          }
        }
      }
    }
  }
  process(START_EVENT_NAME_MAP, startEvents);
  process(END_EVENT_NAME_MAP, endEvents);
}
if (typeof window !== "undefined" && typeof document !== "undefined") {
  detectEvents();
}
function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}
function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}
var TransitionEvents = {
  // Start events
  startEvents,
  addStartEventListener: function addStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }
    startEvents.forEach(function(startEvent) {
      addEventListener(node, startEvent, eventListener);
    });
  },
  removeStartEventListener: function removeStartEventListener(node, eventListener) {
    if (startEvents.length === 0) {
      return;
    }
    startEvents.forEach(function(startEvent) {
      removeEventListener(node, startEvent, eventListener);
    });
  },
  // End events
  endEvents,
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function(endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },
  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function(endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};
var Event_default = TransitionEvents;

// node_modules/@ant-design/css-animation/es/index.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var isCssAnimationSupported = Event_default.endEvents.length !== 0;
var capitalPrefixes = [
  "Webkit",
  "Moz",
  "O",
  // ms is special .... !
  "ms"
];
var prefixes = ["-webkit-", "-moz-", "-o-", "ms-", ""];
function getStyleProperty(node, name) {
  var style = window.getComputedStyle(node, null);
  var ret = "";
  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);
    if (ret) {
      break;
    }
  }
  return ret;
}
function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDelay = parseFloat(getStyleProperty(node, "transition-delay")) || 0;
    var transitionDuration = parseFloat(getStyleProperty(node, "transition-duration")) || 0;
    var animationDelay = parseFloat(getStyleProperty(node, "animation-delay")) || 0;
    var animationDuration = parseFloat(getStyleProperty(node, "animation-duration")) || 0;
    var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
    node.rcEndAnimTimeout = setTimeout(function() {
      node.rcEndAnimTimeout = null;
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1e3 + 200);
  }
}
function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}
var cssAnimation = function cssAnimation2(node, transitionName, endCallback) {
  var nameIsObj = (typeof transitionName === "undefined" ? "undefined" : _typeof(transitionName)) === "object";
  var className = nameIsObj ? transitionName.name : transitionName;
  var activeClassName = nameIsObj ? transitionName.active : transitionName + "-active";
  var end = endCallback;
  var start = void 0;
  var active = void 0;
  if (endCallback && Object.prototype.toString.call(endCallback) === "[object Object]") {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }
  if (node.rcEndListener) {
    node.rcEndListener();
  }
  node.rcEndListener = function(e) {
    if (e && e.target !== node) {
      return;
    }
    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }
    clearBrowserBugTimeout(node);
    node.classList.remove(className);
    node.classList.remove(activeClassName);
    Event_default.removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;
    if (end) {
      end();
    }
  };
  Event_default.addEndEventListener(node, node.rcEndListener);
  if (start) {
    start();
  }
  node.classList.add(className);
  node.rcAnimTimeout = setTimeout(function() {
    node.rcAnimTimeout = null;
    node.classList.add(activeClassName);
    if (active) {
      active();
    }
    fixBrowserByTimeout(node);
  }, 0);
  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};
cssAnimation.style = function(node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }
  node.rcEndListener = function(e) {
    if (e && e.target !== node) {
      return;
    }
    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }
    clearBrowserBugTimeout(node);
    Event_default.removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;
    if (callback) {
      callback();
    }
  };
  Event_default.addEndEventListener(node, node.rcEndListener);
  node.rcAnimTimeout = setTimeout(function() {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }
    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};
cssAnimation.setTransition = function(node, p, value) {
  var property = p;
  var v = value;
  if (value === void 0) {
    v = property;
    property = "";
  }
  property = property || "";
  capitalPrefixes.forEach(function(prefix) {
    node.style[prefix + "Transition" + property] = v;
  });
};
cssAnimation.isCssAnimationSupported = isCssAnimationSupported;
var es_default = cssAnimation;

// node_modules/rc-animate/es/util/animate.js
var util = {
  isAppearSupported: function isAppearSupported(props) {
    return props.transitionName && props.transitionAppear || props.animation.appear;
  },
  isEnterSupported: function isEnterSupported(props) {
    return props.transitionName && props.transitionEnter || props.animation.enter;
  },
  isLeaveSupported: function isLeaveSupported(props) {
    return props.transitionName && props.transitionLeave || props.animation.leave;
  },
  allowAppearCallback: function allowAppearCallback(props) {
    return props.transitionAppear || props.animation.appear;
  },
  allowEnterCallback: function allowEnterCallback(props) {
    return props.transitionEnter || props.animation.enter;
  },
  allowLeaveCallback: function allowLeaveCallback(props) {
    return props.transitionLeave || props.animation.leave;
  }
};
var animate_default = util;

// node_modules/rc-animate/es/AnimateChild.js
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var transitionMap = {
  enter: "transitionEnter",
  appear: "transitionAppear",
  leave: "transitionLeave"
};
var AnimateChild = function(_React$Component) {
  _inherits(AnimateChild2, _React$Component);
  function AnimateChild2() {
    _classCallCheck(this, AnimateChild2);
    return _possibleConstructorReturn(this, (AnimateChild2.__proto__ || Object.getPrototypeOf(AnimateChild2)).apply(this, arguments));
  }
  _createClass(AnimateChild2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stop();
    }
  }, {
    key: "componentWillEnter",
    value: function componentWillEnter(done) {
      if (animate_default.isEnterSupported(this.props)) {
        this.transition("enter", done);
      } else {
        done();
      }
    }
  }, {
    key: "componentWillAppear",
    value: function componentWillAppear(done) {
      if (animate_default.isAppearSupported(this.props)) {
        this.transition("appear", done);
      } else {
        done();
      }
    }
  }, {
    key: "componentWillLeave",
    value: function componentWillLeave(done) {
      if (animate_default.isLeaveSupported(this.props)) {
        this.transition("leave", done);
      } else {
        done();
      }
    }
  }, {
    key: "transition",
    value: function transition(animationType, finishCallback) {
      var _this2 = this;
      var node = import_react_dom.default.findDOMNode(this);
      var props = this.props;
      var transitionName = props.transitionName;
      var nameIsObj = typeof transitionName === "object";
      this.stop();
      var end = function end2() {
        _this2.stopper = null;
        finishCallback();
      };
      if ((isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
        var name = nameIsObj ? transitionName[animationType] : transitionName + "-" + animationType;
        var activeName = name + "-active";
        if (nameIsObj && transitionName[animationType + "Active"]) {
          activeName = transitionName[animationType + "Active"];
        }
        this.stopper = es_default(node, {
          name,
          active: activeName
        }, end);
      } else {
        this.stopper = props.animation[animationType](node, end);
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var stopper = this.stopper;
      if (stopper) {
        this.stopper = null;
        stopper.stop();
      }
    }
  }, {
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);
  return AnimateChild2;
}(import_react3.default.Component);
var AnimateChild_default = AnimateChild;

// node_modules/rc-animate/es/Animate.js
var _extends = Object.assign || function(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass2 = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn2(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var defaultKey = "rc_animate_" + Date.now();
function getChildrenFromProps(props) {
  var children = props.children;
  if (import_react4.default.isValidElement(children)) {
    if (!children.key) {
      return import_react4.default.cloneElement(children, {
        key: defaultKey
      });
    }
  }
  return children;
}
function noop() {
}
var Animate = function(_React$Component) {
  _inherits2(Animate2, _React$Component);
  function Animate2(props) {
    _classCallCheck2(this, Animate2);
    var _this = _possibleConstructorReturn2(this, (Animate2.__proto__ || Object.getPrototypeOf(Animate2)).call(this, props));
    _initialiseProps.call(_this);
    _this.currentlyAnimatingKeys = {};
    _this.keysToEnter = [];
    _this.keysToLeave = [];
    _this.state = {
      children: toArrayChildren(getChildrenFromProps(props))
    };
    _this.childrenRefs = {};
    return _this;
  }
  _createClass2(Animate2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      var showProp = this.props.showProp;
      var children = this.state.children;
      if (showProp) {
        children = children.filter(function(child) {
          return !!child.props[showProp];
        });
      }
      children.forEach(function(child) {
        if (child) {
          _this2.performAppear(child.key);
        }
      });
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;
      this.nextProps = nextProps;
      var nextChildren = toArrayChildren(getChildrenFromProps(nextProps));
      var props = this.props;
      if (props.exclusive) {
        Object.keys(this.currentlyAnimatingKeys).forEach(function(key) {
          _this3.stop(key);
        });
      }
      var showProp = props.showProp;
      var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
      var currentChildren = props.exclusive ? toArrayChildren(getChildrenFromProps(props)) : this.state.children;
      var newChildren = [];
      if (showProp) {
        currentChildren.forEach(function(currentChild) {
          var nextChild = currentChild && findChildInChildrenByKey(nextChildren, currentChild.key);
          var newChild = void 0;
          if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
            newChild = import_react4.default.cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
          } else {
            newChild = nextChild;
          }
          if (newChild) {
            newChildren.push(newChild);
          }
        });
        nextChildren.forEach(function(nextChild) {
          if (!nextChild || !findChildInChildrenByKey(currentChildren, nextChild.key)) {
            newChildren.push(nextChild);
          }
        });
      } else {
        newChildren = mergeChildren(currentChildren, nextChildren);
      }
      this.setState({
        children: newChildren
      });
      nextChildren.forEach(function(child) {
        var key = child && child.key;
        if (child && currentlyAnimatingKeys[key]) {
          return;
        }
        var hasPrev = child && findChildInChildrenByKey(currentChildren, key);
        if (showProp) {
          var showInNext = child.props[showProp];
          if (hasPrev) {
            var showInNow = findShownChildInChildrenByKey(currentChildren, key, showProp);
            if (!showInNow && showInNext) {
              _this3.keysToEnter.push(key);
            }
          } else if (showInNext) {
            _this3.keysToEnter.push(key);
          }
        } else if (!hasPrev) {
          _this3.keysToEnter.push(key);
        }
      });
      currentChildren.forEach(function(child) {
        var key = child && child.key;
        if (child && currentlyAnimatingKeys[key]) {
          return;
        }
        var hasNext = child && findChildInChildrenByKey(nextChildren, key);
        if (showProp) {
          var showInNow = child.props[showProp];
          if (hasNext) {
            var showInNext = findShownChildInChildrenByKey(nextChildren, key, showProp);
            if (!showInNext && showInNow) {
              _this3.keysToLeave.push(key);
            }
          } else if (showInNow) {
            _this3.keysToLeave.push(key);
          }
        } else if (!hasNext) {
          _this3.keysToLeave.push(key);
        }
      });
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      var keysToEnter = this.keysToEnter;
      this.keysToEnter = [];
      keysToEnter.forEach(this.performEnter);
      var keysToLeave = this.keysToLeave;
      this.keysToLeave = [];
      keysToLeave.forEach(this.performLeave);
    }
  }, {
    key: "isValidChildByKey",
    value: function isValidChildByKey(currentChildren, key) {
      var showProp = this.props.showProp;
      if (showProp) {
        return findShownChildInChildrenByKey(currentChildren, key, showProp);
      }
      return findChildInChildrenByKey(currentChildren, key);
    }
  }, {
    key: "stop",
    value: function stop(key) {
      delete this.currentlyAnimatingKeys[key];
      var component = this.childrenRefs[key];
      if (component) {
        component.stop();
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var props = this.props;
      this.nextProps = props;
      var stateChildren = this.state.children;
      var children = null;
      if (stateChildren) {
        children = stateChildren.map(function(child) {
          if (child === null || child === void 0) {
            return child;
          }
          if (!child.key) {
            throw new Error("must set key for <rc-animate> children");
          }
          return import_react4.default.createElement(
            AnimateChild_default,
            {
              key: child.key,
              ref: function ref(node) {
                _this4.childrenRefs[child.key] = node;
              },
              animation: props.animation,
              transitionName: props.transitionName,
              transitionEnter: props.transitionEnter,
              transitionAppear: props.transitionAppear,
              transitionLeave: props.transitionLeave
            },
            child
          );
        });
      }
      var Component = props.component;
      if (Component) {
        var passedProps = props;
        if (typeof Component === "string") {
          passedProps = _extends({
            className: props.className,
            style: props.style
          }, props.componentProps);
        }
        return import_react4.default.createElement(
          Component,
          passedProps,
          children
        );
      }
      return children[0] || null;
    }
  }]);
  return Animate2;
}(import_react4.default.Component);
Animate.isAnimate = true;
Animate.defaultProps = {
  animation: {},
  component: "span",
  componentProps: {},
  transitionEnter: true,
  transitionLeave: true,
  transitionAppear: false,
  onEnd: noop,
  onEnter: noop,
  onLeave: noop,
  onAppear: noop
};
var _initialiseProps = function _initialiseProps2() {
  var _this5 = this;
  this.performEnter = function(key) {
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;
      _this5.childrenRefs[key].componentWillEnter(_this5.handleDoneAdding.bind(_this5, key, "enter"));
    }
  };
  this.performAppear = function(key) {
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;
      _this5.childrenRefs[key].componentWillAppear(_this5.handleDoneAdding.bind(_this5, key, "appear"));
    }
  };
  this.handleDoneAdding = function(key, type) {
    var props = _this5.props;
    delete _this5.currentlyAnimatingKeys[key];
    if (props.exclusive && props !== _this5.nextProps) {
      return;
    }
    var currentChildren = toArrayChildren(getChildrenFromProps(props));
    if (!_this5.isValidChildByKey(currentChildren, key)) {
      _this5.performLeave(key);
    } else if (type === "appear") {
      if (animate_default.allowAppearCallback(props)) {
        props.onAppear(key);
        props.onEnd(key, true);
      }
    } else if (animate_default.allowEnterCallback(props)) {
      props.onEnter(key);
      props.onEnd(key, true);
    }
  };
  this.performLeave = function(key) {
    if (_this5.childrenRefs[key]) {
      _this5.currentlyAnimatingKeys[key] = true;
      _this5.childrenRefs[key].componentWillLeave(_this5.handleDoneLeaving.bind(_this5, key));
    }
  };
  this.handleDoneLeaving = function(key) {
    var props = _this5.props;
    delete _this5.currentlyAnimatingKeys[key];
    if (props.exclusive && props !== _this5.nextProps) {
      return;
    }
    var currentChildren = toArrayChildren(getChildrenFromProps(props));
    if (_this5.isValidChildByKey(currentChildren, key)) {
      _this5.performEnter(key);
    } else {
      var end = function end2() {
        if (animate_default.allowLeaveCallback(props)) {
          props.onLeave(key);
          props.onEnd(key, false);
        }
      };
      if (!isSameChildren(_this5.state.children, currentChildren, props.showProp)) {
        _this5.setState({
          children: currentChildren
        }, end);
      } else {
        end();
      }
    }
  };
};
var Animate_default = unsafeLifecyclesPolyfill_default(Animate);
export {
  Animate_default as default
};
//# sourceMappingURL=rc-animate.js.map
